/**
  * @file vibe-pgm-processor.c
  * \brief Modified ViBe implementation to process PGM image sequences
  *
  * This file contains a modified version of the ViBe example that processes
  * PGM images from a frames folder and outputs processed PGM images.
  *
  * @date March 2025
  * @author Modified from Marc Van Droogenbroeck's original code
*/

#include "vibe-background-sequential.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "dirent.h"
#include <ctype.h>
#include <sys/stat.h>
#include <time.h>

#define _CRT_SECURE_NO_WARNINGS
#define MAX_PATH_LENGTH 512

// Structure to store PGM image information
typedef struct {
    int width;
    int height;
    int max_val;
    unsigned char* data;
} PGMImage;

// Function to read a PGM file
PGMImage* read_pgm(const char* filename) {
    FILE* file = fopen(filename, "rb");
    if (!file) {
        fprintf(stderr, "Error opening file: %s\n", filename);
        return NULL;
    }

    PGMImage* img = (PGMImage*)malloc(sizeof(PGMImage));
    if (!img) {
        fclose(file);
        return NULL;
    }

    // Read the PGM header
    char header[3];
    if (fscanf(file, "%2s", header) != 1) {
        fprintf(stderr, "Error reading PGM header from %s\n", filename);
        fclose(file);
        free(img);
        return NULL;
    }

    // Check if it's a P5 (binary) PGM file
    if (strcmp(header, "P5") != 0) {
        fprintf(stderr, "File %s is not a binary PGM file (P5 format)\n", filename);
        fclose(file);
        free(img);
        return NULL;
    }

    // Skip comments and whitespace
    int c;
    do {
        c = getc(file);
        if (c == '#') {
            // Skip comment line
            while ((c = getc(file)) != '\n' && c != EOF);
        }
    } while (isspace(c));

    // Put back the last non-whitespace character
    ungetc(c, file);

    // Read width, height, and maximum value
    if (fscanf(file, "%d %d", &img->width, &img->height) != 2) {
        fprintf(stderr, "Error reading width/height from %s\n", filename);
        fclose(file);
        free(img);
        return NULL;
    }

    if (fscanf(file, "%d", &img->max_val) != 1) {
        fprintf(stderr, "Error reading max value from %s\n", filename);
        fclose(file);
        free(img);
        return NULL;
    }

    // Ensure max value is valid for PGM
    if (img->max_val > 255 || img->max_val < 0) {
        fprintf(stderr, "Invalid max value in PGM file %s: %d\n", filename, img->max_val);
        fclose(file);
        free(img);
        return NULL;
    }

    // Consume whitespace before binary data
    while (isspace(c = getc(file)));
    ungetc(c, file);

    // Allocate memory for image data
    img->data = (unsigned char*)malloc(img->width * img->height);
    if (!img->data) {
        fprintf(stderr, "Memory allocation failed for %s\n", filename);
        fclose(file);
        free(img);
        return NULL;
    }

    // Read image data
    size_t bytes_read = fread(img->data, 1, img->width * img->height, file);
    if (bytes_read != (size_t)(img->width * img->height)) {
        fprintf(stderr, "Error reading image data from %s (read %lu of %d bytes)\n",
            filename, (unsigned long)bytes_read, img->width * img->height);
        fclose(file);
        free(img->data);
        free(img);
        return NULL;
    }

    fclose(file);
    //printf("Successfully read PGM file: %s (%dx%d)\n", filename, img->width, img->height);
    return img;
}

// Function to write a PGM file
int write_pgm(const char* filename, int width, int height, unsigned char* data) {
    FILE* file = fopen(filename, "wb");
    if (!file) {
        fprintf(stderr, "Error opening file for writing: %s\n", filename);
        return 0;
    }

    // Write PGM header
    fprintf(file, "P5\n");
    fprintf(file, "# Generated by ViBe PGM Processor\n");
    fprintf(file, "%d %d\n", width, height);
    fprintf(file, "255\n");

    // Write image data
    size_t bytes_written = fwrite(data, 1, width * height, file);
    if (bytes_written != (size_t)(width * height)) {
        fprintf(stderr, "Error writing image data to %s (wrote %lu of %d bytes)\n",
            filename, (unsigned long)bytes_written, width * height);
        fclose(file);
        return 0;
    }

    fclose(file);
    return 1;
}

// Function to check if file has .pgm extension (case insensitive)
int has_pgm_extension(const char* filename) {
    const char* dot = strrchr(filename, '.');
    if (!dot || dot == filename) return 0;

    // Convert to lowercase for comparison
    char ext[4];
    int i;
    for (i = 0; i < 3 && dot[i + 1] != '\0'; i++) {
        ext[i] = tolower(dot[i + 1]);
    }
    ext[i] = '\0';

    return (strcmp(ext, "pgm") == 0);
}

// Function to check if file is a regular file
int is_regular_file(const char* path) {
    struct stat path_stat;
    if (stat(path, &path_stat) != 0) {
        return 0;
    }
    return S_ISREG(path_stat.st_mode);
}

// Function to list files in a directory with .pgm extension
char** list_pgm_files(const char* dir_path, int* num_files) {
    DIR* dir;
    struct dirent* entry;
    int count = 0;
    char** file_list = NULL;
    char full_path[MAX_PATH_LENGTH];

    // Open directory
    dir = opendir(dir_path);
    if (!dir) {
        fprintf(stderr, "Error opening directory: %s\n", dir_path);
        *num_files = 0;
        return NULL;
    }

    // First pass: count PGM files
    while ((entry = readdir(dir)) != NULL) {
        snprintf(full_path, MAX_PATH_LENGTH, "%s/%s", dir_path, entry->d_name);
        if (is_regular_file(full_path) && has_pgm_extension(entry->d_name)) {
            count++;
        }
    }

    // Allocate memory for file list
    file_list = (char**)malloc(count * sizeof(char*));
    if (!file_list) {
        fprintf(stderr, "Memory allocation failed for file list\n");
        closedir(dir);
        *num_files = 0;
        return NULL;
    }

    // Second pass: store file names
    rewinddir(dir);
    count = 0;
    while ((entry = readdir(dir)) != NULL) {
        snprintf(full_path, MAX_PATH_LENGTH, "%s/%s", dir_path, entry->d_name);
        if (is_regular_file(full_path) && has_pgm_extension(entry->d_name)) {
            file_list[count] = (char*)malloc(MAX_PATH_LENGTH);
            if (file_list[count]) {
                snprintf(file_list[count], MAX_PATH_LENGTH, "%s/%s", dir_path, entry->d_name);
                count++;
            }
        }
    }

    closedir(dir);
    *num_files = count;
    return file_list;
}

// Function to extract filename from path
char* get_filename(const char* path) {
    char* filename = strrchr(path, '/');
    if (filename) {
        return filename + 1;
    }
    return (char*)path;
}

int main(int argc, char** argv) {
    if (argc < 3) {
        fprintf(stderr, "Usage: %s <input_folder> <output_folder>\n", argv[0]);
        fprintf(stderr, "This program processes .pgm files only.\n");
        return 1;
    }

    // TIMER
    clock_t start, end;
    double time_taken, total_time=0;

    // Initialize dirs
    system("rmdir gray_pgm /s /q");
    system("rmdir bg_subtracted_parallel /s /q");
    system("mkdir gray_pgm");
    system("mkdir bg_subtracted_parallel");

    // Convert vid to pgm 
    system("ffmpeg -i short.mp4 -vf \"fps=5,format=gray\" gray_pgm/grayframe_%04d.pgm");

    const char* input_folder = argv[1];
    const char* output_folder = argv[2];

    printf("ViBe PGM Processor\n");
    printf("------------------\n");
    printf("Input folder: %s\n", input_folder);
    printf("Output folder: %s\n", output_folder);
    printf("------------------\n");

    // List all PGM files in the input folder
    int num_files = 0;
    char** file_list = list_pgm_files(input_folder, &num_files);

    if (num_files == 0) {
        fprintf(stderr, "No PGM files found in %s\n", input_folder);
        return 1;
    }

    printf("Found %d PGM files in %s\n", num_files, input_folder);

    // Load the first image to get dimensions
    PGMImage* first_img = read_pgm(file_list[0]);
    if (!first_img) {
        fprintf(stderr, "Failed to read first image\n");

        // Free file list
        for (int i = 0; i < num_files; i++) {
            free(file_list[i]);
        }
        free(file_list);

        return 1;
    }

    int width = first_img->width;
    int height = first_img->height;
    printf("Image dimensions: %d x %d\n", width, height);

    // Allocate memory for segmentation map
    uint8_t* segmentation_map = (uint8_t*)malloc(width * height);
    if (!segmentation_map) {
        fprintf(stderr, "Failed to allocate memory for segmentation map\n");

        // Free resources
        free(first_img->data);
        free(first_img);

        for (int i = 0; i < num_files; i++) {
            free(file_list[i]);
        }
        free(file_list);

        return 1;
    }

    // Initialize ViBe model
    vibeModel_Sequential_t* model = NULL;
    model = (vibeModel_Sequential_t*)libvibeModel_Sequential_New();

    // Initialize model with first image
    libvibeModel_Sequential_AllocInit_8u_C1R(model, first_img->data, width, height);

    printf("Processing frames...\n");

    // Process all images
    for (int i = 0; i < num_files; i++) {
        // Read the image
        PGMImage* img = (i == 0) ? first_img : read_pgm(file_list[i]);
        if (!img) {
            fprintf(stderr, "Failed to read image %s\n", file_list[i]);
            continue;
        }

        // Verify image dimensions
        if (img->width != width || img->height != height) {
            fprintf(stderr, "Image dimensions mismatch in %s (%dx%d vs expected %dx%d)\n",
                file_list[i], img->width, img->height, width, height);
            free(img->data);
            free(img);
            continue;
        }

        start = clock(); // START TIMER

        // Process the image
        libvibeModel_Sequential_Segmentation_8u_C1R(model, img->data, segmentation_map);

        // Update the model
        libvibeModel_Sequential_Update_8u_C1R(model, img->data, segmentation_map);

        end = clock(); // END TIMER
        time_taken = ((double)(end - start)) * 1E3 / CLOCKS_PER_SEC;
        total_time += time_taken;

        // Create output filename
        char output_filename[MAX_PATH_LENGTH];
        char* base_name = get_filename(file_list[i]);
        snprintf(output_filename, MAX_PATH_LENGTH, "%s/processed_%s", output_folder, base_name);

        // Write the segmentation map to a PGM file
        if (!write_pgm(output_filename, width, height, segmentation_map)) {
            fprintf(stderr, "Failed to write output image %s\n", output_filename);
        }
        else {
            //printf("Wrote output file: %s\n", output_filename);
        }

        // Free image data if not the first image (which is freed later)
        if (i > 0) {
            free(img->data);
            free(img);
        }

        printf("\rProcessed %d/%d images", i + 1, num_files);
        fflush(stdout);
    }

    printf("\nDone processing all images.\n");

    // Convert result back to vid
    system("ffmpeg -framerate 5 -i \"bg_subtracted_parallel/processed_grayframe_%04d.pgm\" -c:v libx264 -pix_fmt yuv420p output_bgsub_parallel.mp4");

    // Cleanup
    libvibeModel_Sequential_Free(model);
    free(segmentation_map);
    free(first_img->data);
    free(first_img);

    for (int i = 0; i < num_files; i++) {
        free(file_list[i]);
    }
    free(file_list);

    double avg_time = time_taken / num_files;
    printf("\n\nAvg Time for SIMD: %llf milliseconds\n", avg_time);

    return 0;
}